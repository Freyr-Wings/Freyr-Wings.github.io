<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文本特征提取]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%96%87%E6%9C%AC%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[循环神经网络RNN及其变种]]></title>
    <url>%2F2018%2F03%2F24%2F%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[这是一篇有关循环神经网络的阅读笔记，阅读来源分别为： https://www.jianshu.com/p/f3bde26febed https://zybuluo.com/hanbingtao/note/541458 http://www.sohu.com/a/220858232_129720 http://www.sohu.com/a/220858232_129720 循环神经网络(RNN)作用循环神经网络(Recurrent Neural Network)，最早是为了处理序列而建立的模型，专门用于处理类似时间序列，视频，文本等具有前后关联性的数据。以此作为动机，不难想到，这个神经网络需要采取一种序列形式的结构，并且能够将所有历史信息与当前信息相结合，从而给出我们需要的结果。下面是RNN的具体结构。 结构 这个网络在$t$时刻接收到输入之后，隐藏层的值是$s_t$，输出值是$o_t$。其中公式如下： o_1=g(Vs_1)\\ s_1=f(Ux_1)\\ o_t=g(Vs_t)\\ s_t=f(Ux_t+Ws_{t-1})\\输出值同时受到上一时刻的隐藏层和当前输入值的影响。 推广在了解RNN的基本结构之后，就可以通过调整输入和输出的结构来完成不同的任务 上图中的5个例子从左到右分别是： 没有使用RNN，从固定大小的输入得到固定大小输出（比如图像分类） 序列输出（比如图片描述，输入一张图片输出一段文字序列） 序列输入（比如情感分析，输入一段文字然后将它分类成积极或者消极情感） 序列输入和序列输出（比如机器翻译） 同步序列输入输出（比如视频分类，对视频中每一帧打标签） 双向循环神经网络(BiRNN)作用上面提到的循环神经网络只考虑了一种方向的依赖性，即当前的数据依赖于过去的数据，从而忽略了未来的数据也可能帮助我们推测当前的数据，由此引入了双向的循环神经网络。 结构 这里仍然采用前一个图的符号表示，公式如下： o_t=g(Vs_t+V's'_t)\\ s_t=f(Ux_t+Ws_{t-1})\\ s'_t=f(U'x_t+W's'_{t+1})\\深度循环神经网络(DRNN)结构当隐藏层多于一层的时候，就形成了深度循环神经网络，下面是一个深度双向的循环神经网络 这里第i个隐藏层表示为$s^{(i)}_{t}$ 和 $s’^{(i)}_{t}$ ，具体公式如下 o_t=g(V^{(i)}s^{(i)}_t+V'^{(i)}s'^{(i)}_t)\\ s^{(i)}_t=f(U^{(i)}s^{(i-1)}_{t}+W^{(i)}s^{(i)}_{t-1})\\ s'^{(i)}_t=f(U'^{(i)}s'^{(i-1)}_{t}+W'^{(i)}s'^{(i)}_{t+1})\\ ……\\ s^{(1)}_t=f(U^{(1)}x_t+W^{(1)}s^{(1)}_{t-1})\\ s'^{(1)}_t=f(U'^{(1)}x_t+W'^{(1)}s'^{(1)}_{t+1})\\长短时记忆网络(LSTM)作用在实际运用中，循环神经网络很难处理长期的依赖，并且很容易产生梯度消失或者梯度爆炸的现象，使得RNN的训练也十分困难。因此在LSTM中引入了一个状态，专门用于保存长期的状态，解决了长期依赖的问题。 结构 遗忘门$f_t$控制上一时刻的单元状态$c_{t-1}$ 有多少被保留到状态$c_t$ 输入门$i_t$ 控制当前输入值$x_t$ 产生的中间状态$\widetilde{c}_t$ 有多少被保留到状态$c_t$ 公式如下： f_t=\sigma(W_f [h_{t-1}, x_t] + b_f)=\sigma(W_{fh}h_{t-1}+W_{fx}x_t + b_f)\\ i_t=\sigma(W_i [h_{t-1}, x_t] + b_i)\\ \widetilde{c}_t=tanh(W_c [h_{t-1}, x_t] + b_c)\\ c_t=f_t\odot c_{t-1}+i_t\odot \widetilde{c}_t\\ o_t=\sigma(W_o [h_{t-1}, x_t] + b_o)\\ h_t=o_t\odot tanh(c_t)Gated Recurrent Unit(GRU)结构 GRU对LSTM做了两个大改动： 将输入门、遗忘门、输出门变为两个门：更新门（Update Gate）$z_t$和重置门（Reset Gate）$r_t$ 将单元状态与输出合并为一个状态$h$ 公式如下： z_t=\sigma(W_z [h_{t-1}, x_t])\\ r_t=\sigma(W_r [h_{t-1}, x_t])\\ \widetilde{h}_t=tanh(W_c [r_t \odot h_{t-1}, x_t])\\ h_t=(1-z_t)\odot h_{t-1}+z_t\odot \widetilde{h}_tNested LSTM作用直观上，LSTM 中的输出门会编码仍旧值得记忆的信息，这些记忆可能与当前的时间步骤不相关。嵌套 LSTM 根据这一直观理解来创造一种记忆的时间层级。访问内部记忆以同样的方式被门控，以便于长期信息只有在情景相关的条件下才能选择性地访问。 结构 f_t=\sigma(W_f [h_{t-1}, x_t] + b_f)\\ i_t=\sigma(W_i [h_{t-1}, x_t] + b_i)\\ c_t=f_t\odot c_{t-1}+i_t\odot tanh(W_c [h_{t-1}, x_t] + b_c)\\ o_t=\sigma(W_o [h_{t-1}, x_t] + b_o)\\ h_t=o_t\odot tanh(c_t)记忆单元的输入和隐藏状态为： \widetilde{h}_{t-1}=f_t\odot c_{t-1}\\ \widetilde{x}_{t}=i_t\odot tanh(W_c [h_{t-1}, x_t] + b_c)\\内部LSTM的计算为： \widetilde{f}_t=\sigma(\widetilde{W}_f [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_f)\\ \widetilde{i}_t=\sigma(\widetilde{W}_i [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_i)\\ \widetilde{c}_t=\widetilde{f}_t\odot \widetilde{c}_{t-1}+\widetilde{i}_t\odot tanh(\widetilde{W}_c [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_c)\\ \widetilde{o}_t=\sigma(\widetilde{W}_o [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_o)\\ \widetilde{h}_t=\widetilde{o}_t\odot tanh(\widetilde{c}_t)如果不看内部LSTM，并且使单元状态为$c_t=\widetilde{h}_{t-1}+\widetilde{x}_{t}$ 则结构就是普通的LSTM，而在嵌套LSTM中，单元状态的更新为： c_t=\widetilde{h}_{t}]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EM算法理解]]></title>
    <url>%2F2018%2F03%2F15%2FEM%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[TO BE CONTINUE..]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[推荐系统与协同过滤]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[本文为对Andrew Ng的推荐系统与协同过滤一章的个人理解。 定义根据不同的数据源发现数据相关性的方法可以分为以下几种： 根据系统用户的基本信息发现用户的相关程度，这种被称为基于人口统计学的推荐（Demographic-based Recommendation） 根据推荐物品或内容的元数据，发现物品或者内容的相关性，这种被称为基于内容的推荐（Content-based Recommendation） 根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，这种被称为基于协同过滤的推荐（Collaborative Filtering-based Recommendation）。 本文中主要涉及的为基于内容的推荐和基于协同过滤的推荐。 标记$n_{user}$代表用户的数量 $n_{movie}$代表电影的数量 $r^{(i, j)}$代表用户i给电影j评过分 $y^{(i, j)}$代表用户i给电影j 的评分 $\hat{y}^{(i, j)}$代表系统预测的用户i给电影j 的评分 $m_j$代表用户j 评过分的电影的总数 基于内容的推荐系统假设每部电影都有一个特征向量$\bf{x}^i$ 假设每个用户心中有一个用于打分的参数向量$\bf{\theta}^j$ 则对预测评分$\hat{y}^{(i, j)}$有： \hat{y}^{(i, j)}=(\bf{\theta}^j)^T\bf{x}^i\\对代价函数$L(\bf{\theta})$有： L(\bf{\theta}^j)=\frac{1}{2}\sum\limits_{i:r^{(i, j)}=1}^{} (\hat{y}^{(i, j)}-y^{(i, j)})^2+\frac{\lambda}{2}||\bf{\theta}^j||_2^2\\ L(\bf{\theta})=\sum\limits_{j=1}^{n_{user}}L(\bf{\theta}^j)最后通过梯度下降法得到$\bf{\theta}$的最优解 个人体会 在这个系统中首先需要给出每部电影的特征，以及部分用户对电影的打分 一方面，可以利用用户的$\theta$来评估未打分的电影的$\hat{y}$，从而将预测打分比较高的推荐给用户 另一方面，可以通过相似性比较找到$\theta$相近的用户，互相为他们推荐电影 协同过滤在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，使用这些特征训练出了每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征。 但如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了。协同过滤算法可以同时学习这两者。此时的优化目标便改为同时针对$\bf{x}$和$\bf{\theta}$进行。 此时损失函数为： L(\bf{\theta}, \bf{x})=\frac{1}{2}\sum\limits_{i:r^{(i, j)}=1}^{} (\hat{y}^{(i, j)}-y^{(i, j)})^2+\frac{\lambda}{2}\sum\limits_{j=1}^{n_{user}}||\bf{\theta}^j||_2^2+\frac{\lambda}{2}\sum\limits_{i=1}^{n_{movie}}||\bf{x}^i||_2^2同时通过梯度下降法对$\bf{x}$和$\bf{\theta}$更新，即可得到所有的特征，并利用这些特征为用户提供推荐。 在协同过滤方法中，我们很显然的会发现，基于协同过滤的推荐系统用可以分为两类： 基于项(item-based)的推荐系统。主要依据的是项与项之间的相似性。 基于用户(user-based)的推荐系统。主要依据的是用户与用户之间的相似性。 而衡量相似性的方式有欧式距离、皮尔逊相关系数和余弦相似度]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Recommender system</tag>
        <tag>Collaborative Filtering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来做个自己的hexo博客吧(2)]]></title>
    <url>%2F2018%2F02%2F27%2Fhexo%E5%8D%9A%E5%AE%A2-2%2F</url>
    <content type="text"><![CDATA[github decoration GitHub Ribbons http://tholman.com/github-corners/ 挑选一个喜欢的样式，然后把对应的代码复制下来 打开文件：themes/next/layout/_layout.swig,搜索&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;。然后把你刚刚复制的代码，粘贴到此处下面，并修改href为你的github的对应地址 头像变成圆形，鼠标停放在上面时可以旋转找到文件themes/next/source/css/_common/components/sidebar/sidebar-author.styl，在其中加入下面注释中间的代码 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 给文章添加阴影效果打开文件themes/next/source/css/_custom/custom.styl，输入以下代码，保存后退出。 12345678// 主页文章 添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 在文章中插入图片在站点配置文件中将post_asset_folder改为true，重新generate，然后通过命令hexo new “title” 生成新的文章，同时也会自动生成文件夹/source/_post/title，在文件夹中放入图片，然后在对应的md文档中输入asset_img pic_name pic_description %&#125;``` 即可。123456789101112131415## 阅读全文在md文档中插入`&lt;!-- more --&gt;`即可## 搜索功能在**站点配置文件**中添加```yamlsearch: path: search.xml field: post format: html limit: 10000 在主题配置文件中找到local_search，将enable改为true即可 不蒜子总访客量与总访问量统计，LeanCloud文章热度然后在主题配置文件中找到busuanzi_count，将enable改为true ，为了避免与文章热度重合，将page_pv 改为false ，然后需要配置leancloud，步骤如下： 进入LeanCloud官网 进行注册 选择创建应用(开发版)-&gt;创建Class(限制写入) 点击左侧设置-&gt;点击应用Key 在主题配置文件中找到leancloud_visitors，填入并修改对应值 至此，文章中已经可以显示文章阅读次数了，同时页面底部会有总访客量和总访问量。 修改阅读次数的icon和文字的方法是： 找到themes/next/languages下对应的语言文件，找到post下的visitors，修改为热度。 找到themes/next/layout/_macro/post.swig，修改部分如下： 1234567891011121314&#123;# LeanCould PageView #&#125;&#123;% if theme.leancloud_visitors.enable %&#125;&lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt;&lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;span class="post-meta-item-icon"&gt;&lt;i class="fa fa-thermometer"&gt;&lt;/i&gt;&lt;/span&gt;&#123;% if theme.post_meta.item_text %&#125;&lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt;&#123;% endif %&#125;&lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;&lt;span&gt;℃&lt;/span&gt;&lt;/span&gt;&#123;% endif %&#125; 统计文章字数，阅读时长在gitbash中输入 1npm i --save hexo-wordcount 修改主题配置文件，将post_wordcount下的值都改为true 添加公式在主题配置文件中找到mathjax，将enable改为true，然后在每篇文档的开头添加mathjax: true，修改完后可以通过一个美元符号包围文字，在行内添加公式，例如$a=\sum_{i=0}^{100}i$，也可以通过两个美元符号包围文字形成行间的公式，如： a=\sum_{i=0}^{100}imathjax在某些情况下可能会出现公式渲染的问题，可以通过以下步骤解决： 在根目录下输入命令 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改根目录下文件node_modules\kramed\lib\rules\inline.js，修改代码 123456// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/......// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 最后执行hexo clean、hexo g -d重新生成博客 文章模板修改/scaffolds/post.md文件，便于每次创建文章时使用 12345678910title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top:tags:categories:description:copyright: truecomments: truemathjax: true&lt;!-- more --&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来做个自己的hexo博客吧(1)]]></title>
    <url>%2F2018%2F02%2F27%2Fhexo%E5%8D%9A%E5%AE%A2-1%2F</url>
    <content type="text"><![CDATA[借助github pages和hexo，可以很方便的搭建起美观而又简洁的博客，还可以随时更改博客界面，添加各种实用的插件进行进一步的美化。本文为搭建博客步骤的简要介绍^_^。 创建github账号，新建repo，命名应与账号名相同配置gitbash中的ssh任意新建一个文件夹用于存放博客和更新博客不需要clone下来第一步新建的repo，但建议的方式是在repo中新建分支保存用于生成博客的文件夹 1234567npm install -g hexo-cli # 安装hexocd (你的文件夹)hexo initnpm install# 通过以上步骤即可初始化完成hexo server # 本地查看部署好的网站npm install hexo-deployer-git --save # 为第五步步骤做准备 打开_config.yml，修改最后一部分1234deploy: type: git repo: git@github.com:Freyr-Wings/Freyr-Wings.github.io.git branch: master 输入命令部署网站1hexo g -d # deploy，将搭建好的网站部署到github.io上 下载主题a-例子-yilialink: https://github.com/litten/hexo-theme-yilia 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 克隆完成后每次更新只需要在文件夹内git pull即可 b-Rank主题排行（from知乎）：https://www.zhihu.com/question/24422335 1git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next c-viosey-material文档：https://material.viosey.com/docs/#/start 1git clone https://github.com/viosey/hexo-theme-material.git themes/material EXTRA输入hexo d后，如果发现配置失败，请直接打开.deploy_git文件夹，通过git push origin master 的方式进行尝试和debug]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2F2018%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

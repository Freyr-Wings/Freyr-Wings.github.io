<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图与节点的表达学习]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%9B%BE%E4%B8%8E%E8%8A%82%E7%82%B9%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本博客是对一个图与表达学习库中涉及的模型进行讲解 表达学习库的地址为：https://github.com/thunlp/OpenNE 图的表示（输入）edgelist用边来表示整个图，这种表达方式更常用一些 12ori_node dest_node weight_float(optional)... adjlist用邻接节点表示整个图 12ori_node dest_node1 dest_node2 dest_node3 dest_node4 ...... feature文件用该文件可以为节点附加额外的特征 1node feature_1 feature_2 ... feature_n 我们希望得到的文件输出123num_of_nodes num_of_dims_of_representationnode_id dim1 dim2 ... dimd... 模型输出1234567model = Node2vec(graph=g, path_length=80, num_paths=10, dim=128, p=1., q=1., window=10)vectors = model.vectors# output&#123;'1248': array([ 9.77877006e-02, ...]), '601': array([-0.24153167, ...]), ...&#125; 评测 Macro-F1=\frac{\sum_{A\in \mathcal{C}}F1(A)}{|\mathcal{C}|} Pr=\frac{\sum_{A\in \mathcal{C}}TP(A)}{\sum_{A\in \mathcal{C}}(TP(A)+FP(A))},R=\frac{\sum_{A\in \mathcal{C}}TP(A)}{\sum_{A\in \mathcal{C}}(TP(A)+FN(A))}\\ Micro-F1=\frac{2*Pr*R}{Pr+R}Notation 符号 含义 W 图的邻接矩阵，\vert V \vert \times \vert V \vert Y 图的嵌入表达，\vert V \vert \times d d 嵌入表达的维数 Graph FactorizationGF的损失函数表达如下： J=\sum_{(i,j)\in E}(W_{ij}-Y_i{Y_j}^T)^2+\lambda\sum_{i}\|Y_i\|^2通过梯度下降调整嵌入表达矩阵。GF认为邻接矩阵上两点对应的值应与两点的表达向量的内积相近，同时对表达向量进行了L2正则化。 参数 参数名 作用 weight_decay L2正则参数 Laplacian Eigenmaps注意，这个方法仅用于无向图 这里额外用到度矩阵$D$和拉普拉斯矩阵$L$ D=diag(d_1, d_2, ...)\\ d_i=\sum_jW_{ij}\\ L=D-WLE的优化函数表达如下： J=\sum_{i,j}\| Y_i-Y_j\|_2^2W_{ij}=tr(Y^TLY)\\ s.t. Y^TDY=I其中的限制条件是为了防止嵌入表达矩阵任意放缩 利用拉格朗日乘子法对目标函数求解 f(Y)=tr(Y^TLY)+tr(\Lambda (Y^TDY-I))\\ \frac{\partial f(Y)}{\partial Y}=2LY+2DY\Lambda=0\\ \therefore LY=-DY\Lambda=\lambda DY\\ \therefore min(J)\Leftrightarrow min(tr(\lambda))特别的注意到 D\cdot \bf{1}= W\cdot \bf{1}所以目标函数有平凡解，对应特征向量为$\bf{1}$，对应特征值为0，为了使目标函数最小而避免平凡解，故而选择特征值大于0的最小的特征值作为$\lambda$，取对应的特征向量作为最后的表达矩阵 SDNESDNE是一个半监督的神经网络模型，由两部分组成 论文中指出下面两个定义： 一阶近似：对于两个点而言，其邻接矩阵上对应的值为一阶近似值 二阶近似：即$W_i$与$W_j$之间的相似性 其损失函数表达如下， \mathcal{L}_{1st}=\sum_{i,j}W_{ij}\| Y_i-Y_j\|_2^2\\ \mathcal{L}_{2nd}=\sum_i\|(\hat{Y}_i-Y_i)\odot B_i \|_2^2\\ B=(W_{ij}\neq0)\times\beta+(W_{ij}=0)\times1,\beta>1特别的，在考虑$\mathcal{L}_{2nd}$的时候提到，可以想到两点之间没有连接，也就是邻接矩阵上值为0，未必就意味着两点之间没有联系，同时对于邻接矩阵为稀疏矩阵的情况下，Autoencoder更倾向于构建零矩阵，因此加入矩阵$B$ 最后，总的损失函数表达如下： \mathcal{L}_{mix}=\mathcal{L}_{2nd}+\alpha\mathcal{L}_{1st}+\nu\mathcal{L}_{reg}其中最后一项为对神经网络的L2正则化 参数 参数名 作用 encoder_layer_list autoencoder中encoder各层的神经元数，如共有2000个点，该参数为[1000, 200]，则autoencoder的网络表示为2000(input)-&gt;1000-&gt;200-&gt;1000-&gt;2000，200为最后嵌入表达的维数 alpha 一阶近似损失中用到的参数 beta 二阶近似损失中用到的参数 nu1 L1正则参数 nu2 L2正则参数 DeepWalk &amp; Node2vecdeepwalk的步骤如下： 图 随机游走得到节点序列 利用skip gram模型得到表达 node2vec唯一的区别是在随机游走的过程中加入了两个参数，分别用于控制得到局部信息和整体信息 其中随机游走的转移概率（从点$v$到点$c$）定义如下： P(c_i=x|c_{i-1}=v)= \begin{cases} \frac{\pi_{vx}}{Z}& \text{if } (v,x)\in E\\ 0& \text{otherwise} \end{cases}其中$Z$为归一化常数 \pi_{vx}=\alpha_{pq}(t,x)\cdot W_{vx}\\ \alpha_{pq}(t,x)= \begin{cases} \frac{1}{p}& \text{if } d_{tx}=0\\ 1& \text{if } d_{tx}=1\\ \frac{1}{q}& \text{if } d_{tx}=2\\ \end{cases},其中d为t与x之间的边数此外node2vec论文中还提到一些边预测和边采样的方式，详见论文。 参数 参数名 作用 dw 是否采用deepwalk，若为True，skip-gram采用层次softmax，否则采用负采样 path_length 随机游走的序列长度 num_paths 每个点随机游走的序列数 p 控制BFS随机游走的参数 q 控制DFS随机游走的参数 LINE同样的，LINE也考虑了一阶近似和二阶近似，在一阶近似中，以预测概率和经验概率的KL散度作为损失函数 预测概率p_{1ij}=\frac{1}{1+exp(-Y_i{Y_j}^T)}\\ 经验概率\hat{p}_{2ij}=\frac{W_{ij}}{\sum_{(i,j)\in E} W_{ij}}\\ \mathcal{L}_{1st}=-\sum_{(i,j)\in E}W_{ij}\text{ log }p_{1ij}\\在计算二阶近似时，LINE认为每个点应当有两个表达，一个是表达点本身，即$Y$，另一个则是作为其他点的特定context存在，这里记作$Y’$，两者都是待学习的参数，具体损失函数如下： 预测概率p_{2}(v_j|v_i)=\frac{\text{exp}(Y_i{Y_j}'^T)}{\sum_{k=1}^{|V|}\text{exp}(Y_i{Y_k}'^T))}\\ 经验概率\hat{p}_{2}(v_j|v_i)=\frac{W_{ij}}{d_i},d_i为点i的出度\\ \mathcal{L}_{2nd}=-\sum_{(i,j)\in E}W_{ij}\text{ log }p_{2}(v_j|v_i)\\与node2vec类似，这里边采样也采用alias sample进行加速，并采用负采样加速训练效果 参数 参数名 作用 negative_ratio 负采样数量，默认为5，即每1个正样本对应5个负样本 order 采用一阶近似计算或是二阶近似进行计算或是两者结合，对应值1或2或3]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Network Embedding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络阅读笔记（五）链路层]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络第五章阅读笔记 概述节点(node)：运行链路层协议的设备（主机、路由器、交换机、wifi接入点） 链路(link)：连接相邻节点的通信信道 链路层协议可能提供的服务 成帧：将网络层数据包用链路层帧封装起来 链路接入：媒体访问控制(Medium Access Control, MAC)协议规定了帧在链路上传输的规则 可靠交付：保证无差错地经链路层移动每个网络层数据报 差错检测和纠正 两种链路类型：点对点链路、广播链路 差错检测和纠正技术差错检测和纠正比特(Error-Detection and Correction, EDC) 三种技术：奇偶校验、检验和、循环冗余检测 奇偶校验奇偶校验位(parity bit) 方法：附加一个比特，选择值使得初始信息加上校验比特后1的总数为偶数（偶校验方案） 二维奇偶校验(two-dimensional parity) 方法：将初始信息中的d个比特划分为i行j列，对每行每列计算奇偶值，共有i+j+1个奇偶比特 前向纠错(Forward Error Correction, FEC)：接收方检测和纠正差错 校验和(Check sum)将数据的字节作为16比特的整数进行求和，和的反码即为检验和。接收方对所有数据（包括校验和）求和，得到结果全为1比特 循环冗余检测(Cyclic Redundancy Check, CRC)生成多项式(generator)：发送方和接收方协商的r+1位比特串，表示为G 方法：发送方在被发送的数据比特d后面添加r个附加比特，使得最终的d+r个比特可以被G整除 R=remainder\frac{D*2^r}{G}注：在计算过程中，加法和减法都采用XOR操作 多路访问链路和协议多路访问问题：如何协调多个发送和接收节点对一个共享广播信道的访问，相关协议称为多路访问协议 多路访问协议应有特性： 当仅有一个结点有数据要发送时，结点应具有R bps的吞吐量 当有M个结点要发送数据时，在一定时间间隔内结点应有R/M 的平均传输速率 协议是分散的，不会因为主节点故障而崩溃 协议简单易实现 信道划分协议(channel partitioning protocol)时分多路复用(time-division multiplexing)将时间划分为时间帧(time frame)，每个时间帧再划分为N个时隙(slot)，把每个时隙分配给N个结点中的一个 缺陷： 节点被限制于R/N bps的平均速率 节点必须等待它在传输序列中的轮次 频分多路复用(frequency-division multiplexing)将R bps信道划分为不同频段，并把每个频率分配给N个节点中的一个，其优缺点与TDM相同 码分多址(code division multiple access, CDMA)：见第6章 随机接入协议(random access protocol)方式： 传输结点总是以信道的全部速率发送 涉及碰撞的结点反复重发它的帧，直到该帧无碰撞通过 重发帧之前等待一个随机时延 时隙ALOHA协议 必须在时隙起点开始传输帧 以概率p重传 最大效率为1/e ALOHA 不限定开始传输的时刻 以概率p立刻重传，1-p概率等待一个帧传输时间再重新判定 最大效率为1/2e 载波侦听多路访问(Carrier Sense Multiple Access, CSMA)载波监听(Carrier sensing)：一个结点在传输前先检测信道是否正在传输帧（如何实现？） 碰撞检测(collision detection)：结点在传输过程中监听信道，如果检测到另一个结点正在传输则停止传输 (CSMA with Collision Detection, CSMA/CD) 在碰撞检测中停止传输后，适配器等待一个随机时间量（二进制指数后退），然后继续监听信道是否空闲。 二进制指数后退(binary exponential backoff)：假设该帧经历了n次碰撞，则从{0, 1, 2 … 2^n-1}中选择K，等待K*512比特时间，当10\le n \le 15 时，n=10，当n\ge 16 时，停止传输 轮流协议(taking-turns protocol)轮询协议(polling protocol)方式：指定一个主节点，由主节点以循环的方式轮询每个节点 缺陷： 引入了轮询时延 如果主节点故障，则整个信道也会停止工作 令牌传递协议(token-passing protocol)方式：一个称为令牌的小的特殊帧在节点之间以固定的次序进行交换，只有当节点收到令牌并且有帧要传输时才发送最大数目的帧数，然后将令牌传递给下一个节点 缺陷：固定次序中的任意节点故障或是令牌操作不当都会引起信道崩溃 DOCSIS(Data-Over-Cable Service Interface Specifications)关键词：数据经电缆服务接口(DOCSIS), 电缆调制解调器端接系统(cable modem termination system, CMTS) 交换局域网MAC地址（LAN地址/物理地址） 主机或路由器网络接口的链路层地址 长度为6字节 广播地址是48个连续的1组成的字串 MAC与IP的区别与联系 对于网络上的某一设备，如一台计算机或一台路由器，其IP地址可变（但必须唯一），而MAC地址不可变。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址永远唯一且不能由用户改变。 长度不同。IP地址为32位，MAC地址为48位。 分配依据不同。IP地址的分配是基于网络拓朴，MAC地址的分配是基于制造商。 寻址协议层不同。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。 https://blog.csdn.net/yang_best/article/details/41643589 地址解析协议(Address Resolution Protocol, ARP) ARP只为在同一个子网上的主机和路由器接口解析IP地址 每台主机或路由器内存中维护一个ARP表 IP地址 MAC地址 TTL 222.222.222.221 88-B2-2F-54-1A-0F 13:45:00 222.222.222.223 5C-66-AB-90-75-B1 13:52:00 当对应表项不存在时，发送方构造一个ARP分组(ARP packet)，用MAC广播地址发送这个分组。分组中包含发送和接收IP地址和MAC地址 发送数据报到子网外： 每台路由器有N个接口（对应N个IP地址），一个ARP模块，一个适配器（对应一个MAC地址） 发送适配器首先通过ARP发送帧到第一跳路由器，然后该帧被传递给网络层进而移动到目的地。 以太网以太网帧结构 名称 作用 大小 前同步码(Preamble) 用于同步时钟 8字节 目的地址 目的适配器的MAC地址 6字节 源地址 源适配器MAC地址 6字节 类型字段 网络层协议编号 2字节 数据字段 46-1500字节 循环冗余检测(CRC) 4字节 链路层交换机过滤：决定转发或是丢弃某个帧 转发：决定一个帧被导向哪个接口，并将该帧移动到那个接口 交换机表：对应3种转发情况(没有对应项，x=x，y!=x) 地址 接口 时间 62-FE-F7-11-89-A3 1 9:32 7C-BA-B2-B4-91-10 3 9:36 自学习： 交换机表初始为空 在表中存储每个接口接收到的入帧 在老化期后删除表项 性质： 消除碰撞：不会因碰撞而浪费带宽 异质的链路：将链路隔离从而允许不同链路运行在不同媒体上 管理：更强的安全性 ex即插即用：不需要管理员或用户干预，而路由器需要用户配置IP 交换机和路由器交换机 即插即用 分组过滤和转发速率高 广播需要采用生成树 大型网络需要维护大的ARP表 没有对于网络风暴的保护措施 路由器 分组传输可采用最佳路径 为广播风暴提供防火墙包含 不是即插即用 虚拟局域网(Virtula Local Network, VLAN)单一物理局域网基础设施定义多个局域网 交换机维护端口到VLAN的映射表]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络阅读笔记（四）网络层]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络第四章阅读笔记 概述（网络层的三个重要功能）转发（forwarding）当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路 网际协议（IP)，网络层编址，IPv4数据报格式，网络地址转换（NAT)，数据报分段，因特网控制报文协议（ICMP），IPv6 路由选择（routing）当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。 两种流行算法（链路状态和距离矢量算法），等级制路由选择方法（因特网自治系统内部：RIP，OSPF，IS-IS；因特网自治系统之间：BGP），广播和多播的路由选择 连接建立（connection setup）允许发送方和接收方建立所需的状态信息通过某种方式进行交流 ATM、帧中继、MPLS 虚电路和数据报网络虚电路(Virtual-Circuit, VC)仅在网络层提供连接服务的计算机网络 虚电路组成 源和目的主机之间的路径（一系列链路和路由器） VC号，沿着该路径的每段链路的一个号码 沿着该路径的每台路由器中的转发表表项 数据报网络(datagram network)仅在网络层提供无连接服务的计算机网络 每台路由器有一个将目的地址映射到链路接口的转发表。根据最长前缀匹配规则进行转发 前缀匹配 链路接口 11001000 00010111 00010 0 11001000 00010111 00011000 1 11001000 00010111 00011 2 其他 3 路由器输入端口 线路端接 数据链路处理 查找，转发，排队 . （协议，拆封） 根据转发表的副本查找输出端口（转发表由路由选择处理器计算和更新） 对于双向链路，其输入和输出端口在同一线路卡上成对出现 交换结构 经内存交换 经总线交换 经纵横式网络交换 输出端口 排队 数据链路处理 线路端接 （缓存管理） （协议，拆封） . 输出端口排队分组调度程序(packet scheduler)用于在排队的分组中选择一个来发送 例如：先来先服务调度(FCFS)，加权公平排队(WFQ) 主动队列管理(Active Queue Management, AQM)丢包：路由器缓存空间耗尽，无内存可用于存储到达的分组，造成分组被丢弃 主动队列管理：在缓存填满前便丢弃（或在首部加标记）一个分组，以便向发送方提供一个拥塞信号，例如：随机早期检测(Random Early Detection, RED) 输入端口排队线路前部(Head-Of-the-Line, HOL)阻塞：在一个输入队列中排队的分组必须等待通过交换结构发送（即时输出端口是空闲的），因为它被位于线路前部的另一个分组所阻塞 网际协议名词 IP数据报分片（ID，偏移，标志flag） 子网(subnet) 子网掩码(network mask) 无类别域间路由选择(CIDR, Classless Interdomain Routing)：因特网地址分配策略 IP地址分类https://blog.csdn.net/liufangbaishi2014/article/details/51954437 IPv6变化 扩大的地址容量：IPv6将IP地址长度从32位增加到128位，IPv6用8组16位来表示，4位数字用冒号分隔，比如2001:0db8:0000:0000:0000:ff00:0042:8329 简化的首部：IPv6舍弃了许多原有的字段，使数据报能够更快更灵活的处理 流标签和优先级 路由选择算法链路状态(Link State, LS)路由选择算法p283-26 Step N’ D(t),p(t) D(u),p(u) D(v),p(v) D(w),p(w) D(y),p(y) D(z),p(z) 0 x ∞ ∞ 3,x 6,x 6,x 8,x 1 xv 7,v 6,v 3,x 6,x 6,x 8,x 2 xvu 7,v 6,v 3,x 6,x 6,x 8,x 3 xvuw 7,v 6,v 3,x 6,x 6,x 8,x 4 xvuwy 7,v 6,v 3,x 6,x 6,x 8,x 5 xvuwyt 7,v 6,v 3,x 6,x 6,x 8,x 6 xvuwytz 7,v 6,v 3,x 6,x 6,x 8,x 距离向量(Distance-Vector, DV)路由选择算法p284-29 u v x y z v ∞ ∞ ∞ ∞ ∞ x ∞ ∞ ∞ ∞ ∞ z ∞ 6 2 ∞ 0 u v x y z v 1 0 3 ∞ 6 x ∞ 3 0 3 2 z 7 5 2 5 0 u v x y z v 1 0 3 3 5 x 4 3 0 3 2 z 6 5 2 5 0 u v x y z v 1 0 3 3 5 x 4 3 0 3 2 z 6 5 2 5 0 AS(Autonomous System)内部路由选择协议（内部网关协议）路由选择信息协议(Routing Information Protocol, RIP) RIP是一种距离向量协议 跳：从源路由器到目的子网（包括目的子网！）的最短路径所经过的子网数量 RIP响应报文/RIP通告 使用UDP报文段进行传输 开放最短路优先(Open Shortest Path First, OSPF)核心：使用洪泛链路状态信息的链路状态协议，Dijkstra最低费用路径算法 优点： 安全：能够鉴别OSPF路由器之间的交换 允许使用多条路径 对单播和多播路由选择的综合支持 支持单个路由选择域内的层次结构 AS(Autonomous System)间的路由选择：BGP(Border Gateway Protocol, 边界网关协议)基础关键词： BGP对等方：位于TCP连接端点的两台路由器 外部BGP会话：跨越两个AS的BGP会话 内部BGP会话：在同一个AS中的两台路由器之间的BGP会话 通过179端口的半永久TCP连接来交换路由选择信息 使用CDIR化的前缀(prefix)表示子网或者子网的集合 路由属性和BGP路由 自治系统号(Autonomous System Number, ASN)：全局唯一标识一个自治系统 路由：带有BGP属性的前缀 AS-PATH属性：包含前缀的通告已经通过的AS，用于检测和防止循环通告 NEXT-HOP属性：是一开始某AS-PATH的路由器接口，用于正确配置转发表&amp;TODO； BGP路由选择根据一定的规则从多条路由中选择出一条，P266 路由选择策略防止客户网络承担提供商网络之间的流量 防止主干提供商出现免费搭车的现象 广播路由选择算法N次单播无控制洪泛缺陷：广播风暴 受控洪泛序号控制洪泛(sequence-number-controlled flooding)每个节点维护一个序号列表，在接收广播分组时先检查分组是否在列表中，如果在就丢弃该分组。 反向路径转发(Reverse Path Forwarding, RPF)仅当分组到达的链路正好位于自己返回源的最短单播路径上 生成树广播最小生成树：所有生成树中费用最小的生成树 节点不必知道整棵树，只需要知道哪些邻居是它在生成树中的邻居 基于中心的方法：节点向中心节点单播加入树报文 多播问题 如何标识多播分组的接收方 如何为接收方的分组编址 因特网组管理协议(IGMP) 承载在IP数据报中，协议号为2 membership_query, membership_report, leave_group 多播路由选择算法使用一棵组共享树的多播路由选择使用基于中心的方法构造多播路由选择树，与对应多播组相关的路由器才经过单播发送加入报文 使用一棵基于源的树的多播路由选择使用RPF算法+剪枝 因特网中的多播路由选择 距离向量多播路由选择协议(Distance Vector Multicast Routing Protocol, DVMRP)：反向路径转发+剪枝 协议无关的多播(Protocol Independent Multicast, PIM)路由选择协议: 稠密模式：洪泛与剪枝反向路径转发技术，类似DVMRP 稀疏模式：聚集点建立多播分发树 源特定多播(Source-Specific Multicast, SSM)：发送给多播接收方的分组必须来自一个指定的源地址，限制了来源从而减少网络要求，提高了安全性]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络阅读笔记（三）运输层]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络第三章阅读笔记 概述UDP：不可靠、无连接的服务 TCP：可靠、面向连接的服务 基本职责：将两个端系统间IP的交付服务拓展为运行在端系统上的两个进程之间的交付服务，称为运输层的多路复用(transport-layer multiplexing)与多路分解(demultiplexing) 多路复用与多路分解多路分解将运输层报文段中的数据交付到正确的套接字 实现：检查报文段中的端口号并定向到相应的套接字实现 多路复用源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，然后传递到网络层 无连接与面向连接的UDP套接字通过二元组（目的IP地址，目的端口号）来标识 TCP套接字通过四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识 UDP(User Datagram Protocol)用户数据报协议采用UDP的原因： 对发送速率有要求，并能容忍数据丢失 UDP不会引入建立连接的时延，例如DNS UDP不维护连接状态 分组首部开销小 TCP：电子邮件、远程终端访问、web及文件传输 UDP：RIP路由选择表更新、SNMP简单网络管理协议 、DNS 可靠数据传输原理可靠数据传输协议(reliable data transfer protocol) rdt1.0直接调用udt_send函数实现 rdt2.0&amp;自动重传请求协议(Automatic Repeat reQuest)ARQ协议包括： 差错检测（与UDP中通过校验码检测差错类似，详见第5章） 接收方反馈（ACK与NAK） 重传 停等协议：发送方只有在确信接收方已经正确接收当前分组之后才会发送一块新数据。 rdt2.1&amp;2.2rdt2.0缺陷：没有考虑ACK或NAK分组受损的情况，从而发送方无法确定是发送新数据块还是重传 解决方案：为数据分组编号，当ACK或NAK分组受损时，发送方重传上一个分组，接收方也可根据编号知道发送方是否在重传前一个分组。 rdt3.0rdt2.2缺陷：没有考虑丢包的问题 解决方案：（由发送方负责检测和恢复丢包工作）实现基于时间的重传机制，加入定时器 流水线技术(pipelining)rdt3.0缺陷：是停等协议，性能低下 解决方案：流水线技术 影响： 必须增加序号范围 协议发送方和接收方必须缓存多个分组 具体取决于差错恢复的方式：回退N步(Go-Back-N, GBN)和选择重传(Selective repeat, SR) 回退N步(GBN)发送方响应三类事件： 上层的调用：检查发送窗口是否已满 收到一个ACK：表示该序号及以前的所有分组已经被正确接收 超时事件：重传所有已发送但未被确认的分组 接收方：如果分组被正确接收并且按序，则为分组发送一个ACK，否则丢弃该分组，并为最近按序接受的分组重新发送ACK 选择重传(SR)发送方动作： 上层的调用：检查发送窗口是否已满 收到一个ACK：如果分组序号在窗口内，则将该分组标记为已接收，如果其序号等于send_base，则窗口移动到具有最小序号的未被确认分组处 超时事件：重传超时的分组，每个分组都有自己的逻辑定时器 接收方动作： 分组序号在窗口内，分组被正确接收并回送对应的ACK 分组序号在窗口前，必须产生一个ACK 其他情况：忽略分组 SR接收方窗口太大困境：新分组or重传？ 解决方案：窗口长度必须小于或等于序号空间大小的一半 可靠数据传输机制及其用途总结：p154 TCP(Transmission Control Protocol)传输控制协议名词解释 MSS(maximum segment size)：TCP的最大报文段长度 MSL(maximum segment lifetime)：报文段能在网络中存在的最长时间。 TTL(time to live)：IP数据报在网络中能够经历的最大跳数，即能够经过的最大路由数。 RTT(round trip time)：指客户端到服务端往返所花时间。 MTU(maximum transmission unit)：最大传输单元，一个链路层帧能承载的最大数据量。 序号(Sequence number)：报文段首字节字节流编号 确认号(Acknowledgement number)：期望收到的下一字节的序号 估计往返时间与超时仅为已发送但是未被确认的分组测量SampleRTT EstimatedRTT=(1-\alpha)*EstimatedRTT + \alpha*SampleRTT\\ EstimatedRTT=0.875*EstimatedRTT + 0.125*SampleRTTRTT偏差： DevRTT=(1-\beta)*DevRTT + \beta*|SampleRTT-EstimatedRTT|\\ DevRTT=0.75*DevRTT + 0.25*|SampleRTT-EstimatedRTT|超时间隔，初始值为1s： TimeoutInterval=EstimatedRTT+4*DevRTT快速重传两次duplicated ACK肯定是乱序造成的 丢包肯定会造成三次duplicated ACK 快速重传：在报文段的定时器过期之前重传丢失的报文段 https://www.zhihu.com/question/21789252 流量控制接收窗口：用于指示发送方接收方还有多少可用的缓存空间 LastByteSent-LastByteAcked\le rwnd三次握手 TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态； TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 为什么TCP客户端最后还要发送一次确认呢？ 一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误 四次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么客户端最后还要等待2MSL？ MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器 https://blog.csdn.net/qzcsu/article/details/72861891 拥塞控制原因与代价 当分组的到达速率接近链路容量时，分组经历巨大的排队时延 当数据报被丢失时发送方必须重传，因此引入了重传开销 发送方在时延大时的不必要重传，浪费链路带宽 当数据报被丢失时，丢失路由器的上游路由器做的工作都变成了无用功 控制方法 端到端的拥塞控制（通过TCP报文段丢失确定） 网络辅助的拥塞控制（路由器向发送方提供拥塞状态的反馈信息）（包括直接网络反馈（发送拥塞分组）和经接收方的网络反馈（标记拥塞）） TCP拥塞控制算法指导性原则 丢失的报文段意味着拥塞，应当降低发送方速率 对先前未确认的报文段的确认到达时，应当增加发送方速率 带宽检测：ACK到达时增加速率，丢包时减少速率 https://blog.csdn.net/goodluckwhh/article/details/10161753 慢启动 在慢启动状态，cwnd的值以1个MSS开始，并且每当传输的报文段首次被确认就增加一个MSS 如果存在一个由超时指示的丢包事件，发送方就将cwnd设置为1并重新开始慢启动，同时将ssthresh（慢启动阈值，cwnd=ssthresh时由慢启动进入拥塞避免模式）置为拥塞窗口值的一半。 如果检测到3个冗余ACK，则进入快速恢复状态 拥塞避免cwnd的值大约是上次拥塞时值的一半 每个RTT将cwnd的值增加一个MSS（实现方式是：每受到一个新确认，就将cwnd增加一个MSS(MSS/cwnd)，这样一个RTT会接收到cwnd/MSS个确认） 超时则进入慢启动状态 如果检测到3个冗余ACK，则进入快速恢复状态 快速恢复 收到另外的重复的ACK时，cwnd增加一个MSS。 当收到确认新数据包的ACK时，把cwnd设置为ssthresh的值，转移到拥塞避免的状态 超时则进入慢启动状态 回顾加性增、乘性减(Additive-Increase, Multiplicative-Decrease, AIMD) 乘法减小： 是指不论在慢启动阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢启动门限值ssthresh 设置为当前的拥塞窗口值乘以0.5。当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。 加法增大： 是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞 时延计算首先要注意传输速率指的是将数据推向链路上的速率，而传播时延则对应为比特在链路上传播所需的时间，与物理媒体和链路长度有关，和RTT相对应 然后假设传播速率（发送速率）为R，一个分组长度为M，窗口大小为W=nM，发送数据大小为L 注意到R是会直接影响到拥塞窗口的大小的，因为如果R足够大，那么一个RTT时间内可以传输无数个分组，以致于接收方不停的丢包，那么就有一个最适合当前发送速率的拥塞窗口大小 假设当前处在拥塞避免阶段，每次成功接收到 \frac{W}{M}=n 个新ACK后，窗口大小都会增加M，并逐渐趋向于在一个RTT内，发送所有的\frac{W}{M} 个分组，也就是\frac{W}{RTT}\rightarrow R ，此时，倘若还没有出现丢包，也就说明接收方的接受速度足够快，并且没有拥塞，那么拥塞窗口继续增大，所有的RTT时间内都会有数据进行传输，传输进入稳定状态。特别的，一个RTT里并非刚好能够传整数个分组，而只是按照流水线的方式持续不断的传输以保证没有空闲。 在这种情况下，拥塞窗口大小有 W \ge \lceil \frac{RTT}{M/R}\rceil + 1计算上TCP握手所需要的时间RTT，总共时延为 T=2RTT+L/R]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络阅读笔记（二）应用层]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络第二章阅读笔记 应用层协议原理体系结构客户-服务器体系结构（服务器有固定周知的IP，配备大量主机的数据中心） P2P体系结构 进程通信 发起通信的为客户，等待联系的是服务器 套接字是应用层和运输层之间的接口，也称API 标识接收进程：主机地址（IP地址）+接收进程的标识符（端口号） 运输层协议提供的服务可靠数据传输、吞吐量（特定的传输速率）、定时（时延控制）、安全性 Web和HTTPURL地址：服务器主机名+对象路径名 cookie四个组件： HTTP响应报文中的cookie首部行 HTTP请求报文中的cookie首部行 用户端系统保留的cookie文件，由浏览器进行管理 web站点的后台数据库 关键词：Set-Cookie、用户标识 HTTP1.0与HTTP1.1差异 请求方法，HTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT这些Request方法以及新的状态码 HTTP 1.1则支持持久连接。Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。 在同一个tcp的连接中可以传送多个HTTP请求和响应。 HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。 HTTP 1.1和1.0都是可以扩展的，通过cookie，session，增强应用层 https://blog.csdn.net/hguisu/article/details/8608888 Web缓存与条件GET方法web缓存器，也叫代理服务器，用于在存储空间内保存最近请求过的对象的副本 web缓存器作用： 减少对客户请求的响应时间 减少机构的接入链路到因特网的通信量（不必急于增加带宽） 通过条件GET证实缓存器中的对象是最新的，客户端向服务器发送一个请求询问是否在上一次访问网站的时间后是否更改了页面（请求报文使用GET方法+请求报文包含一个If-Modified-Since首部行） 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since: Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 如果没有更改： 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果发生更改就把客户端的请求当作一个普通的Get请求发送相应报文 文件传输协议FTP使用两个并行的TCP连接来传输文件 控制连接（贯穿整个用户会话）：用户标识、口令、改变远程目录 数据连接（每次文件传输都建立新的连接）：文件传输 关键词：带外传送 下面是一些常用命令，它们经控制信道以ASCII 文本发送： USER username：用于向服务器传送用户标识。PASS password：用于向服务器传送用户口令。LIST：返回当前目录中的文件列表，文件列表是在（新建的非持久连接）数据连接上传送的。RETR filename：获取(get) 文件，该命令触发远程主机发起一个数据连接，并在该数据连接上发送所请求文件。STOR filename：存储 (put)文件到远程主机。 下面是一些常见的状态码及相应短语(如在HTTP中的那样)： 331 Username OK, password required125 data connection already open; transfer starting425 Can’t open data connection452 Error writing file 电子邮件三个组成部分：用户代理、邮件服务器、简单邮件传输协议（SMTP） SMTP(Simple Mail Transfer Protocol)用于从发送方的邮件服务器发送报文到接收方的邮件服务器，一般不使用中间邮件服务器发送邮件 123456789101112131415S: 220 hamburger.edu // 与服务器创建TCP连接之后，服务器响应220标识服务就绪C: HELO crepes.fr // 向服务器标识用户身份S: 250 Hello crepes.fr, pleased to meet you // 服务器返回欢迎信息C: MAIL FROM: &lt;alice@crepes.fr&gt; // 指定发送者邮箱S: 250 alice@crepes.fr ... Sender ok // C: RCPT TO: &lt;bob@hamburger.edu&gt; // 指定接受者邮箱S: 250 bob@hamburger.edu ... Recipient ok // C: DATA // 请求发送数据S: 354 Enter mail, end with “.” on a line by itself // 开始邮件输入C: Do you like ketchup? // C: How about pickles? // C: . // 以包含一个句点的行指示报文结束S: 250 Message accepted for delivery // 接收成功C: QUIT // 退出链接S: 221 hamburger.edu closing connection // 服务器关闭传输通道 HTTP与SMTP 两者都使用持续连接，但HTTP是拉协议，SMTP是推协议 SMTP限制使用7比特ASCII码格式，而HTTP不限制 对于既包含文本又包含文件的文档，HTTP将每个对象封装到其独立的响应报文中，而SMTP将所有对象放在一个报文中 邮件访问协议POP3(Post Office Protocol-ver3) POP3命令格式 说明 user username user 命令是POP3客户端程序与POP3邮件服务器建立连接后通常发送的第一条命令，参数 username 表示收件人的帐户名称。 pass password pass 命令是在user命令成功通过后，POP3客户端程序接着发送的命令，它用于传递帐户的密码，参数 password 表示帐户的密码。 apop name,digest apop 命令用于替代user和pass命令，它以MD5 数字摘要的形式向POP3邮件服务器提交帐户密码。 stat stat 命令用于查询邮箱中的统计信息，例如：邮箱中的邮件数量和邮件占用的字节大小等。 uidl msg# uidl 命令用于查询某封邮件的唯一标志符，参数msg#表示邮件的序号，是一个从1开始编号的数字。 list [MSG#] list 命令用于列出邮箱中的邮件信息，参数 msg#是一个可选参数，表示邮件的序号。当不指定参数时，POP3服务器列出邮箱中所有的邮件信息；当指定参数msg#时，POP3服务器只返回序号对应的邮件信息。 retr msg# retr 命令用于获取某封邮件的内容，参数 msg#表示邮件的序号。 dele msg# dele 命令用于在某封邮件上设置删除标记，参数msg#表示邮件的序号。POP3服务器执行dele命令时，只是为邮件设置了删除标记，并没有真正把邮件删除掉，只有POP3客户端发出quit命令后，POP3服务器才会真正删除所有设置了删除标记的邮件。 rest rest 命令用于清除所有邮件的删除标记。 top msg# n top 命令用于获取某封邮件的邮件头和邮件体中的前n行内容，参数msg#表示邮件的序号，参数n表示要返回邮件的前几行内容。使用这条命令以提高 Web Mail系统（通过Web站点上收发邮件）中的邮件列表显示的处理效率，因为这种情况下不需要获取每封邮件的完整内容，而是仅仅需要获取每封邮件的邮件头信息。 noop noop 命令用于检测POP3客户端与POP3服务器的连接情况。 quit quit 命令表示要结束邮件接收过程，POP3服务器接收到此命令后，将删除所有设置了删除标记的邮件，并关闭与POP3客户端程序的网络连接。 IMAP(Internet Mail Access Protocol) 提供创建文件夹和移动邮件的功能 提供远程文件夹查询邮件的功能 允许用户代理获取报文组件而不必取回完整邮件 两者比较 IMAP具有摘要浏览功能，可以让用户在读完所有邮件的主题、发件人、大小等信息后，再由用户做出是否下载或直接在服务器上删除的决定。 IMAP可以让用户有选择性地下载邮件附件。例如一封邮件包含3个附件，如果用户确定其中只有2个附件对自已有用，就可只下载这2个附件，而不必下载整封邮件，从而节省了下载时间。 IMAP可以让用户在邮件服务器上创建自己的邮件夹，分类保存各个邮件。 DNS(Domain Name System 域名系统)(采用UDP)作用：主机名到IP地址转换的目录服务 DNS是 一个由分层的DNS服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 递归查询：请求主机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机 迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询 https://jocent.me/2017/06/18/dns-protocol-principle.html DHCP(Dynamic Host Configuration)动态主机配置协议(采用UDP)四个步骤 discover，客户通过广播发送发现报文 offer，服务器通过广播为客户端提供可选的IP地址、网络掩码、IP地址租用期 request，客户端选定IP，向对应的服务器发送请求报文 ACK，对请求报文进行响应，表示用户可以在租借期内使用该IP地址。 其他参考： https://blog.csdn.net/qq_35644234/article/details/68961603 https://blog.csdn.net/u014558484/article/details/53150038]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络阅读笔记（一）综述]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[计算机网络第一章阅读笔记 五层因特网协议栈 因特网协议栈 作用 应用层 HTTP SMTP FTP DNS 运行在不同主机上的进程使用应用层协议进行通信 ，其分组称为报文message 运输层 TCP和UDP， 提供了在应用程序端点之间传送应用层报文的服务，其分组称为报文段segment 网络层 IP， 负责将数据报独立地从信源发送到信宿 ，其分组称为数据报datagram 链路层 负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，帧frame 物理层 负责将比特流在结点间传输，即负责物理传输 七层ISO OSI参考模型 名称 作用 应用层 表示层 使通信的应用程序能够解释交换数据的含义：数据压缩、数据加密、数据描述 会话层 会话控制和同步 运输层 网络层 链路层 物理层 接入网家庭接入数字用户线(Digital Subscriber Line, DSL)、电缆、光纤到户(Fiber To The Home, FTTH)、拨号、卫星 企业（家庭）接入以太网、WiFi（基于IEEE802.11技术的无线LAN接入） 广域无线接入3G（第三代移动通信技术 ）、LTE（“Long-Term Evolution”） 电路交换和分组交换网络链路和交换机移动数据的两种基本方法 分组交换源将长报文划分为较小的分组(packet)，通过通信链路和分组交换机传送 存储转发传输(store-and-forward transmission)：交换机能够开始向链路传输该分组的第一个比特之前必须接受到整个分组 排队时延和分组丢失 转发表和路由选择协议 缺点：不适合实时服务，端到端时延不可预测 优点：提供了更好的带宽共享；比电路交换简单有效，成本低 电路交换在端系统通信期间，预留了端系统间沿路径所需要的资源 分组交换时延处理时延：检查分组首部和决定该分组去向 排队时延：分组在链路上等待被传输 传输时延：将分组所有比特推向链路所需的实际时间 传播时延：比特从链路起点传输到终点所需时间]]></content>
      <categories>
        <category>Computer Networking</category>
      </categories>
      <tags>
        <tag>Computer Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环神经网络RNN及其变种]]></title>
    <url>%2F2018%2F03%2F24%2F%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[这是一篇有关循环神经网络的阅读笔记，阅读来源分别为： https://www.jianshu.com/p/f3bde26febed https://zybuluo.com/hanbingtao/note/541458 http://www.sohu.com/a/220858232_129720 http://www.sohu.com/a/220858232_129720 循环神经网络(RNN)作用循环神经网络(Recurrent Neural Network)，最早是为了处理序列而建立的模型，专门用于处理类似时间序列，视频，文本等具有前后关联性的数据。以此作为动机，不难想到，这个神经网络需要采取一种序列形式的结构，并且能够将所有历史信息与当前信息相结合，从而给出我们需要的结果。下面是RNN的具体结构。 结构 这个网络在$t$时刻接收到输入之后，隐藏层的值是$s_t$，输出值是$o_t$。其中公式如下： o_1=g(Vs_1)\\ s_1=f(Ux_1)\\ o_t=g(Vs_t)\\ s_t=f(Ux_t+Ws_{t-1})\\输出值同时受到上一时刻的隐藏层和当前输入值的影响。 推广在了解RNN的基本结构之后，就可以通过调整输入和输出的结构来完成不同的任务 上图中的5个例子从左到右分别是： 没有使用RNN，从固定大小的输入得到固定大小输出（比如图像分类） 序列输出（比如图片描述，输入一张图片输出一段文字序列） 序列输入（比如情感分析，输入一段文字然后将它分类成积极或者消极情感） 序列输入和序列输出（比如机器翻译） 同步序列输入输出（比如视频分类，对视频中每一帧打标签） 双向循环神经网络(BiRNN)作用上面提到的循环神经网络只考虑了一种方向的依赖性，即当前的数据依赖于过去的数据，从而忽略了未来的数据也可能帮助我们推测当前的数据，由此引入了双向的循环神经网络。 结构 这里仍然采用前一个图的符号表示，公式如下： o_t=g(Vs_t+V's'_t)\\ s_t=f(Ux_t+Ws_{t-1})\\ s'_t=f(U'x_t+W's'_{t+1})\\深度循环神经网络(DRNN)结构当隐藏层多于一层的时候，就形成了深度循环神经网络，下面是一个深度双向的循环神经网络 这里第i个隐藏层表示为$s^{(i)}_{t}$ 和 $s’^{(i)}_{t}$ ，具体公式如下 o_t=g(V^{(i)}s^{(i)}_t+V'^{(i)}s'^{(i)}_t)\\ s^{(i)}_t=f(U^{(i)}s^{(i-1)}_{t}+W^{(i)}s^{(i)}_{t-1})\\ s'^{(i)}_t=f(U'^{(i)}s'^{(i-1)}_{t}+W'^{(i)}s'^{(i)}_{t+1})\\ ……\\ s^{(1)}_t=f(U^{(1)}x_t+W^{(1)}s^{(1)}_{t-1})\\ s'^{(1)}_t=f(U'^{(1)}x_t+W'^{(1)}s'^{(1)}_{t+1})\\长短时记忆网络(LSTM)作用在实际运用中，循环神经网络很难处理长期的依赖，并且很容易产生梯度消失或者梯度爆炸的现象，使得RNN的训练也十分困难。因此在LSTM中引入了一个状态，专门用于保存长期的状态，解决了长期依赖的问题。 结构 遗忘门$f_t$控制上一时刻的单元状态$c_{t-1}$ 有多少被保留到状态$c_t$ 输入门$i_t$ 控制当前输入值$x_t$ 产生的中间状态$\widetilde{c}_t$ 有多少被保留到状态$c_t$ 公式如下： f_t=\sigma(W_f [h_{t-1}, x_t] + b_f)=\sigma(W_{fh}h_{t-1}+W_{fx}x_t + b_f)\\ i_t=\sigma(W_i [h_{t-1}, x_t] + b_i)\\ \widetilde{c}_t=tanh(W_c [h_{t-1}, x_t] + b_c)\\ c_t=f_t\odot c_{t-1}+i_t\odot \widetilde{c}_t\\ o_t=\sigma(W_o [h_{t-1}, x_t] + b_o)\\ h_t=o_t\odot tanh(c_t)Gated Recurrent Unit(GRU)结构 GRU对LSTM做了两个大改动： 将输入门、遗忘门、输出门变为两个门：更新门（Update Gate）$z_t$和重置门（Reset Gate）$r_t$ 将单元状态与输出合并为一个状态$h$ 公式如下： z_t=\sigma(W_z [h_{t-1}, x_t])\\ r_t=\sigma(W_r [h_{t-1}, x_t])\\ \widetilde{h}_t=tanh(W_c [r_t \odot h_{t-1}, x_t])\\ h_t=(1-z_t)\odot h_{t-1}+z_t\odot \widetilde{h}_tNested LSTM作用直观上，LSTM 中的输出门会编码仍旧值得记忆的信息，这些记忆可能与当前的时间步骤不相关。嵌套 LSTM 根据这一直观理解来创造一种记忆的时间层级。访问内部记忆以同样的方式被门控，以便于长期信息只有在情景相关的条件下才能选择性地访问。 结构 f_t=\sigma(W_f [h_{t-1}, x_t] + b_f)\\ i_t=\sigma(W_i [h_{t-1}, x_t] + b_i)\\ c_t=f_t\odot c_{t-1}+i_t\odot tanh(W_c [h_{t-1}, x_t] + b_c)\\ o_t=\sigma(W_o [h_{t-1}, x_t] + b_o)\\ h_t=o_t\odot tanh(c_t)记忆单元的输入和隐藏状态为： \widetilde{h}_{t-1}=f_t\odot c_{t-1}\\ \widetilde{x}_{t}=i_t\odot tanh(W_c [h_{t-1}, x_t] + b_c)\\内部LSTM的计算为： \widetilde{f}_t=\sigma(\widetilde{W}_f [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_f)\\ \widetilde{i}_t=\sigma(\widetilde{W}_i [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_i)\\ \widetilde{c}_t=\widetilde{f}_t\odot \widetilde{c}_{t-1}+\widetilde{i}_t\odot tanh(\widetilde{W}_c [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_c)\\ \widetilde{o}_t=\sigma(\widetilde{W}_o [\widetilde{h}_{t-1}, \widetilde{x}_t] + \widetilde{b}_o)\\ \widetilde{h}_t=\widetilde{o}_t\odot tanh(\widetilde{c}_t)如果不看内部LSTM，并且使单元状态为$c_t=\widetilde{h}_{t-1}+\widetilde{x}_{t}$ 则结构就是普通的LSTM，而在嵌套LSTM中，单元状态的更新为： c_t=\widetilde{h}_{t}]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统与协同过滤]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[本文为对Andrew Ng的推荐系统与协同过滤一章的个人理解。 定义根据不同的数据源发现数据相关性的方法可以分为以下几种： 根据系统用户的基本信息发现用户的相关程度，这种被称为基于人口统计学的推荐（Demographic-based Recommendation） 根据推荐物品或内容的元数据，发现物品或者内容的相关性，这种被称为基于内容的推荐（Content-based Recommendation） 根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，这种被称为基于协同过滤的推荐（Collaborative Filtering-based Recommendation）。 本文中主要涉及的为基于内容的推荐和基于协同过滤的推荐。 标记$n_{user}$代表用户的数量 $n_{movie}$代表电影的数量 $r^{(i, j)}$代表用户i给电影j评过分 $y^{(i, j)}$代表用户i给电影j 的评分 $\hat{y}^{(i, j)}$代表系统预测的用户i给电影j 的评分 $m_j$代表用户j 评过分的电影的总数 基于内容的推荐系统假设每部电影都有一个特征向量$\bf{x}^i$ 假设每个用户心中有一个用于打分的参数向量$\bf{\theta}^j$ 则对预测评分$\hat{y}^{(i, j)}$有： \hat{y}^{(i, j)}=(\bf{\theta}^j)^T\bf{x}^i\\对代价函数$L(\bf{\theta})$有： L(\bf{\theta}^j)=\frac{1}{2}\sum\limits_{i:r^{(i, j)}=1}^{} (\hat{y}^{(i, j)}-y^{(i, j)})^2+\frac{\lambda}{2}||\bf{\theta}^j||_2^2\\ L(\bf{\theta})=\sum\limits_{j=1}^{n_{user}}L(\bf{\theta}^j)最后通过梯度下降法得到$\bf{\theta}$的最优解 个人体会 在这个系统中首先需要给出每部电影的特征，以及部分用户对电影的打分 一方面，可以利用用户的$\theta$来评估未打分的电影的$\hat{y}$，从而将预测打分比较高的推荐给用户 另一方面，可以通过相似性比较找到$\theta$相近的用户，互相为他们推荐电影 协同过滤在之前的基于内容的推荐系统中，对于每一部电影，我们都掌握了可用的特征，使用这些特征训练出了每一个用户的参数。相反地，如果我们拥有用户的参数，我们可以学习得出电影的特征。 但如果我们既没有用户的参数，也没有电影的特征，这两种方法都不可行了。协同过滤算法可以同时学习这两者。此时的优化目标便改为同时针对$\bf{x}$和$\bf{\theta}​$进行。 此时损失函数为： L(\bf{\theta}, \bf{x})=\frac{1}{2}\sum\limits_{i:r^{(i, j)}=1}^{} (\hat{y}^{(i, j)}-y^{(i, j)})^2+\frac{\lambda}{2}\sum\limits_{j=1}^{n_{user}}||\bf{\theta}^j||_2^2+\frac{\lambda}{2}\sum\limits_{i=1}^{n_{movie}}||\bf{x}^i||_2^2同时通过梯度下降法对$\bf{x}$和$\bf{\theta}$更新，即可得到所有的特征，并利用这些特征为用户提供推荐。 在协同过滤方法中，我们很显然的会发现，基于协同过滤的推荐系统用可以分为两类： 基于项(item-based)的推荐系统。主要依据的是项与项之间的相似性。 基于用户(user-based)的推荐系统。主要依据的是用户与用户之间的相似性。 而衡量相似性的方式有欧式距离、皮尔逊相关系数和余弦相似度]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Recommender system</tag>
        <tag>Collaborative Filtering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来做个自己的hexo博客吧(2)]]></title>
    <url>%2F2018%2F02%2F27%2Fhexo%E5%8D%9A%E5%AE%A2-2%2F</url>
    <content type="text"><![CDATA[github decoration GitHub Ribbons http://tholman.com/github-corners/ 挑选一个喜欢的样式，然后把对应的代码复制下来 打开文件：themes/next/layout/_layout.swig,搜索&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;。然后把你刚刚复制的代码，粘贴到此处下面，并修改href为你的github的对应地址 头像变成圆形，鼠标停放在上面时可以旋转找到文件themes/next/source/css/_common/components/sidebar/sidebar-author.styl，在其中加入下面注释中间的代码 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 给文章添加阴影效果打开文件themes/next/source/css/_custom/custom.styl，输入以下代码，保存后退出。 12345678// 主页文章 添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 在文章中插入图片在站点配置文件中将post_asset_folder改为true，重新generate，然后通过命令hexo new “title” 生成新的文章，同时也会自动生成文件夹/source/_post/title，在文件夹中放入图片，然后在md文档中需要插入图片的地方输入 1&#123;% asset_img pic_name pic_description %&#125; 阅读全文在md文档中插入&lt;!-- more --&gt;即可 搜索功能在站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 在主题配置文件中找到local_search，将enable改为true即可 不蒜子总访客量与总访问量统计，LeanCloud文章热度然后在主题配置文件中找到busuanzi_count，将enable改为true ，为了避免与文章热度重合，将page_pv 改为false ，然后需要配置leancloud，步骤如下： 进入LeanCloud官网 进行注册 选择创建应用(开发版)-&gt;创建Class(限制写入) 点击左侧设置-&gt;点击应用Key 在主题配置文件中找到leancloud_visitors，填入并修改对应值 至此，文章中已经可以显示文章阅读次数了，同时页面底部会有总访客量和总访问量。 修改阅读次数的icon和文字的方法是： 找到themes/next/languages下对应的语言文件，找到post下的visitors，修改为热度。 找到themes/next/layout/_macro/post.swig，修改部分如下： 1234567891011121314&#123;# LeanCould PageView #&#125;&#123;% if theme.leancloud_visitors.enable %&#125;&lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;" class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt;&lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;span class="post-meta-item-icon"&gt;&lt;i class="fa fa-thermometer"&gt;&lt;/i&gt;&lt;/span&gt;&#123;% if theme.post_meta.item_text %&#125;&lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt;&#123;% endif %&#125;&lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;&lt;span&gt;℃&lt;/span&gt;&lt;/span&gt;&#123;% endif %&#125; 统计文章字数，阅读时长在gitbash中输入 1npm i --save hexo-wordcount 修改主题配置文件，将post_wordcount下的值都改为true 添加公式在主题配置文件中找到mathjax，将enable改为true，然后在每篇文档的开头添加mathjax: true，修改完后可以通过一个美元符号包围文字，在行内添加公式，例如$a=\sum_{i=0}^{100}i$，也可以通过两个美元符号包围文字形成行间的公式，如： a=\sum_{i=0}^{100}imathjax在某些情况下可能会出现公式渲染的问题，可以通过以下步骤解决： 在根目录下输入命令 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改根目录下文件node_modules\kramed\lib\rules\inline.js，修改代码 123456// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/......// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 最后执行hexo clean、hexo g -d重新生成博客 文章模板修改/scaffolds/post.md文件，便于每次创建文章时使用 12345678910title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top:tags:categories:description:copyright: truecomments: truemathjax: true&lt;!-- more --&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来做个自己的hexo博客吧(1)]]></title>
    <url>%2F2018%2F02%2F27%2Fhexo%E5%8D%9A%E5%AE%A2-1%2F</url>
    <content type="text"><![CDATA[借助github pages和hexo，可以很方便的搭建起美观而又简洁的博客，还可以随时更改博客界面，添加各种实用的插件进行进一步的美化。本文为搭建博客步骤的简要介绍^_^。 创建github账号，新建repo，命名应与账号名相同配置gitbash中的ssh任意新建一个文件夹用于存放博客和更新博客不需要clone下来第一步新建的repo，但建议的方式是在repo中新建分支保存用于生成博客的文件夹 1234567npm install -g hexo-cli # 安装hexocd (你的文件夹)hexo initnpm install# 通过以上步骤即可初始化完成hexo server # 本地查看部署好的网站npm install hexo-deployer-git --save # 为第五步步骤做准备 打开_config.yml，修改最后一部分1234deploy: type: git repo: git@github.com:Freyr-Wings/Freyr-Wings.github.io.git branch: master 输入命令部署网站1hexo g -d # deploy，将搭建好的网站部署到github.io上 下载主题a-例子-yilialink: https://github.com/litten/hexo-theme-yilia 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 克隆完成后每次更新只需要在文件夹内git pull即可 b-Rank主题排行（from知乎）：https://www.zhihu.com/question/24422335 1git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next c-viosey-material文档：https://material.viosey.com/docs/#/start 1git clone https://github.com/viosey/hexo-theme-material.git themes/material EXTRA输入hexo d后，如果发现配置失败，请直接打开.deploy_git文件夹，通过git push origin master 的方式进行尝试和debug]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2F2018%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
